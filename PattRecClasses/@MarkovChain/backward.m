function betaHat=backward(mc,pX,c)%betaHat=backward(mc,pX,c)%calculates scaled observation probabilities,%using the backward algorithm, for a given single MarkovChain,%to be used when the MarkovChain is part of a HMM object.%%Input:%mc= MarkovChain object%pX= matrix with state-conditional likelihood values,%   without considering the Markov depencence between sequence samples.%	pX(j,t)= P( X(t)= observed x(t) | S(t)= j )%	(must be pre-calculated externally)%   NOTE: pX may be arbitrarily scaled, as defined externally,%   i.e. it may not be a properly normalized probability density or mass.%%c=row vector with observation probabilities, obtained from Forward method:%	c(t)=P[x(t) | x(1)...x(t-1),HMM]; t=1..T%	c(1)*c(2)*..c(t)=P[x(1)..x(t)| HMM]%   If the HMM has Finite Duration, the last element includes%   the probability that the HMM ended at exactly the given sequence length, i.e.%   c(T+1)=P( S(T+1)=N+1| x(1)...x(T-1), x(T)  )%Thus, for an infinite-duration HMM:%   length(c)=T%   prod(c)=P( x(1)..x(T) )%and, for a finite-duration HMM:%   length(c)=T+1%   prod(c)=P( x(1)..x(T), S(T+1)=END )%%Result:%betaHat=matrix with scaled backward probabilities:%	betaHat(j,t)=beta(j,t)/(c(t)*..c(T)), where%	beta(j,t)=P[x(t+1)...x(T)| S(t)=j] for an infinite-duration HMM without END state%	beta(j,t)=P[x(t+1)...x(T),S(T+1)=END| S(t)=j] for a finite-duration HMM%%NOTE: %For an infinite-duration HMM:%   P[S(t)=j|x(1)..x(T)]= alfaHat(j,t)*betaHat(j,t)*c(t)%For a finite-duration HMM with separate END state:%   P[S(t)=j|x(1)..x(T), S(T+1)=END]= alfaHat(j,t)*betaHat(j,t)*c(t)%%Ref: Arne Leijon (200x) Pattern Recognition.%%Arne Leijon 2007-08-16 tested (changed definition of scale factors)%           2009-09-29 tested (changed test for finite duration)	nT = size(pX,2);%Number of observations	nS = size(pX,1);%Number of states	a  = mc.TransitionProb;%mc=  a single MarkovChain object	b  = pX;	fD = finiteDuration(mc);    betaHat= zeros(size(pX));	% First iteration from equation  5.64 and 5.65	if fD		betaHat(:,nT)   = a(:,nS+1)./(c(nT)*c(nT+1));    else		betaHat(:,nT)   = ones(nS,1)./c(nT);	end	% start iteration from equation 5.70	for t=nT-1:-1:1		for i=1:nS			if fD %eliminating the end state				sum_b        = sum(a(i,1:end-1).*b(:,t+1).'.*betaHat(:,t+1).');			else %covering the end state				sum_b        = sum(a(i,:).*b(:,t+1).'.*betaHat(:,t+1).');			end			betaHat(i,t)= sum_b / c(t);		end    endend